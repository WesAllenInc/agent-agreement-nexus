/// <reference lib="webworker" />
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute, NavigationRoute } from 'workbox-routing';
import { CacheFirst, StaleWhileRevalidate, NetworkFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

declare const self: ServiceWorkerGlobalScope;

// Precache all assets generated by your build process
// This uses the __WB_MANIFEST variable injected by workbox-webpack-plugin
precacheAndRoute(self.__WB_MANIFEST);

// Cache the page shell (the HTML document) using a NetworkFirst strategy
// This ensures users get fresh content but can still access the app offline
const handler = createHandlerBoundToURL('/index.html');
const navigationRoute = new NavigationRoute(handler, {
  // Don't serve the handler for API requests, etc.
  denylist: [
    /\/api\//,
    /\/auth\//,
    /\/__data.json$/,
  ],
});
registerRoute(navigationRoute);

// Cache static assets with a CacheFirst strategy
registerRoute(
  ({ request }) => request.destination === 'style' || 
                   request.destination === 'script' || 
                   request.destination === 'font',
  new CacheFirst({
    cacheName: 'static-assets',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// Cache images with a CacheFirst strategy
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// Cache API responses with a StaleWhileRevalidate strategy
// This strategy will use a cached version if available, but fetch an
// updated version in the background for next time
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/') || 
               url.href.includes('supabase.co'),
  new StaleWhileRevalidate({
    cacheName: 'api-responses',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 10 * 60, // 10 minutes
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// Background sync for failed POST requests to /api/
const BG_SYNC_QUEUE = 'bg-sync-queue';

async function queueRequest(request: Request) {
  const db = await openQueueDB();
  const tx = db.transaction(BG_SYNC_QUEUE, 'readwrite');
  const store = tx.objectStore(BG_SYNC_QUEUE);
  const cloned = {
    url: request.url,
    method: request.method,
    headers: Array.from(request.headers.entries()),
    body: await request.clone().text(),
    timestamp: Date.now()
  };
  await store.add(cloned);
  await new Promise<void>((resolve, reject) => {
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
  db.close();
}

async function openQueueDB() {
  return await new Promise<IDBDatabase>((resolve, reject) => {
    const req = indexedDB.open('pwa-bg-sync', 1);
    req.onupgradeneeded = () => {
      req.result.createObjectStore(BG_SYNC_QUEUE, { autoIncrement: true });
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function replayQueue() {
  const db = await openQueueDB();
  const tx = db.transaction(BG_SYNC_QUEUE, 'readwrite');
  const store = tx.objectStore(BG_SYNC_QUEUE);
  const all = await new Promise<any[]>((resolve) => {
    const req = store.getAll();
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => resolve([]);
  });
  for (const reqData of all) {
    try {
      await fetch(reqData.url, {
        method: reqData.method,
        headers: reqData.headers,
        body: reqData.body,
      });
      // Remove from queue after successful replay
      // Find by timestamp (unique enough for demo)
      const cursorReq = store.openCursor();
      cursorReq.onsuccess = (ev) => {
        const cursor = (ev.target as IDBRequest).result;
        if (cursor && cursor.value.timestamp === reqData.timestamp) {
          cursor.delete();
        } else if (cursor) {
          cursor.continue();
        }
      };
    } catch (err) {
      // Keep in queue if failed
    }
  }
  await new Promise<void>((resolve, reject) => {
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
  db.close();
}

self.addEventListener('sync', (event) => {
  if (event.tag === 'bg-sync') {
    event.waitUntil(replayQueue());
  }
});

self.addEventListener('online', () => {
  replayQueue();
});

// Handle offline fallbacks and queue failed POSTs
self.addEventListener('fetch', (event) => {
  const req = event.request;
  if (
    req.method === 'POST' &&
    req.url.includes('/api/')
  ) {
    event.respondWith(
      fetch(req.clone()).catch(async () => {
        await queueRequest(req.clone());
        // TypeScript: Background Sync API is not in standard DOM types, so we cast for compatibility
if ('sync' in self.registration) {
  await (self.registration.sync as unknown as { register: (tag: string) => Promise<void> }).register('bg-sync');
}
        return new Response(
          JSON.stringify({
            queued: true,
            message: 'Request queued for background sync.'
          }),
          { status: 202, headers: { 'Content-Type': 'application/json' } }
        );
      })
    );
    return;
  }
  // Offline fallback for navigation
  if (req.mode === 'navigate') {
    event.respondWith(
      fetch(req).catch(() => caches.match('/offline.html'))
    );
  }
});

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Clean up old caches
self.addEventListener('activate', (event) => {
  const currentCaches = ['static-assets', 'images', 'api-responses'];
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (!currentCaches.includes(cacheName)) {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});
